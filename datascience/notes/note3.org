#+LATEX_HEADER: \newenvironment{lequation}{\begin{equation}\Large}{\end{equation}}
#+ATTR_LATEX: :width 5cm :options angle=90
#+TITLE: Algorithm when DataMining3
#+AUTHOR: 杨 睿
#+EMAIL: yangruipis@163.com
#+KEYWORDS: Machine Learning
#+OPTIONS: H:4 toc:t 


* 推荐算法 / 推荐系统

推荐书籍：
- 《推荐系统实践》项亮http://book.douban.com/subject/10769749/
- 《Recommender Systems Handbook》Paul B. Kantor  http://book.douban.com/subject/3695850/

** 前言

*** 隐式反馈和显式反馈

- 显式反馈：用户对某物品表示了明显的喜好，如标记是否喜欢、评分、收藏等。特点：行为较少
- 隐式反馈：未表示明显喜好，用户兴趣不明确，如浏览日志、购买行为。特点：数量庞大

** 推荐算法类别

*** 基于内容的推荐

利用项目的内在品质或者固有属性来进行推荐，比如音乐的流派、类型，电影的风格、类别等，不需要构建UI矩阵（User-Item矩阵）

- 优点：避免 =冷启动= 问题，即一个item从来没被关注过，则不会有推荐算法推荐，导致马太效应，流行的越流行，不流行的越不流行
- 缺点：很可能推荐的东西和所浏览过的一致

*** 基于协同过滤的推荐

**** 基于内存的

都需要将数据全部读入内存中

***** 基于用户的协同推荐
***** 基于项目的协同推荐


**** 基于模型的

- 包括 Aspect Model, pLSA, LDA, 聚类, SVD, Matrix Factorization, 贝叶斯网络
- 训练时间较长，但是训练出来之后推荐过程较快


*** 基于知识的推荐 / 混合推荐


** 基于内容的推荐

Andrew NG课程

ref:  http://lib.csdn.net/article/machinelearning/1101

假设Item有k个属性，每个Item对应得到长为(k+1)的属性向量x（包含了偏移项，为0）。那么每个User对Item每个属性存在一个偏好向量 θ，该向量长度同样为k+1，而 θ是未知的、不可观测的，需要进行估计。

在UI矩阵中，存在一部分未知的值，如果将每个User的 θ可以估计出来，那么未知的值也可以通过 θ^T x 得到，因此我们根据UI矩阵现有的值，估计 θ。见如下公式，其中 y(i,j)是UI矩阵第i行第j列的值，j表示第j个用户，i表示第i个Item，第二项为正则项，防止过拟合。


[[file:pics/content_based_RS.png]]


该式可用梯度下降方法求解，详细见博客。

** 基于内存的协同过滤推荐
ref: https://www.cnblogs.com/baihuaxiu/p/6617389.html

*** 基于用户的

每个用户为样本，每个项目为特征，计算每个用户的相似度，在最相似的用户中，推荐其他人有但是其没有的项目

*** 基于项目的

每个项目为样本，每个用户位特征，计算每个项目的相似度，将最相似的项目关联，如果用户买了其中一个另一个没买，则进行推荐


*** 存在的问题
比如一些非常流行的商品可能很多人都喜欢，这种商品推荐给你就没什么意义了，所以计算的时候需要对这种商品加一个权重或者把这种商品完全去掉也行。

再有，对于一些通用的东西，比如买书的时候的工具书，如现代汉语词典，新华字典神马的，通用性太强了，推荐也没什么必要了。


** 基于模型的协同过滤推荐

对于一个UI矩阵，里面元素是用户对商品的打分。因为很多用户并未尝试过某些商品，所以必将有大量元素未知。

~推荐系统的目标就是预测出UI矩阵中的未知元素~

*** 矩阵分解

ref:
- http://blog.csdn.net/sun_168/article/details/20637833
- https://www.jianshu.com/p/71bcad876c05

另UI矩阵为R, 矩阵分解可以得到 R = UV （U表示用户因子矩阵，V为商品因子矩阵），假设共有n个用户，m个商品

\begin{eqnarray}
\nonumber
R_{n \times m} = U_{n \times k} V · I_{k \times m}
\end{eqnarray}

我们要做的是估计出U和I矩阵，从而对R矩阵中的缺失值进行预测

解决方法：
**** 构建目标函数

ref: http://blog.csdn.net/google19890102/article/details/51124556

\begin{eqnarray}
\nonumber
L = \sum_{i=1}^n \sum_{j=1}^m (R_{ij} - U_i^T I_j)^2
\end{eqnarray}

由于L对U和I都是凸函数，因此可以直接用梯度下降法，求局部最优解


为了防止过拟合，可在其中加入正则项

\begin{eqnarray}
\nonumber
L = \sum_{i=1}^n \sum_{j=1}^m [(R_{ij} - U_i^T I_j)^2 + \lambda_1 ||U_i||^2 + \lambda_2 ||I_j||^2]
\end{eqnarray}



* 机器学习算法调试
** 梯度检查
* 数据库

